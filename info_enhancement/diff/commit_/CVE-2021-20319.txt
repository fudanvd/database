diff --git a/fixtures/verify/1M.gz b/fixtures/verify/1M.gz
new file mode 100644
index 00000000..14b17383
Binary files /dev/null and b/fixtures/verify/1M.gz differ
diff --git a/fixtures/verify/1M.gz.sig b/fixtures/verify/1M.gz.sig
new file mode 100644
index 00000000..ba574bd9
Binary files /dev/null and b/fixtures/verify/1M.gz.sig differ
diff --git a/src/download.rs b/src/download.rs
index ff2de927..3f977808 100644
--- a/src/download.rs
+++ b/src/download.rs
@@ -477,6 +477,11 @@ mod tests {
             &include_bytes!("../fixtures/verify/1M.sig")[..],
             &[0; 1 << 20][..],
         );
+        test_one_signed_file(
+            &include_bytes!("../fixtures/verify/1M.gz")[..],
+            &include_bytes!("../fixtures/verify/1M.gz.sig")[..],
+            &[0; 1 << 20][..],
+        );
         test_one_signed_file(
             &include_bytes!("../fixtures/verify/1M.xz")[..],
             &include_bytes!("../fixtures/verify/1M.xz.sig")[..],
diff --git a/src/io.rs b/src/io.rs
index 66907086..c64d4ecf 100644
--- a/src/io.rs
+++ b/src/io.rs
@@ -196,7 +196,23 @@ impl<R: BufRead> Read for DecompressReader<R> {
         use CompressDecoder::*;
         match &mut self.decoder {
             Uncompressed(d) => d.read(buf),
-            Gzip(d) => d.read(buf),
+            Gzip(d) => {
+                let count = d.read(buf)?;
+                if count == 0 {
+                    // GzDecoder stops reading as soon as it encounters the
+                    // gzip trailer, so it doesn't notice trailing data,
+                    // which indicates something wrong with the input.  Try
+                    // reading one more byte, and fail if there is one.
+                    let mut buf = [0; 1];
+                    if d.get_mut().read(&mut buf)? > 0 {
+                        return Err(io::Error::new(
+                            ErrorKind::InvalidData,
+                            "found trailing data after compressed gzip stream",
+                        ));
+                    }
+                }
+                Ok(count)
+            }
             Xz(d) => d.read(buf),
         }
     }
@@ -249,7 +265,7 @@ impl<R: Read> Read for LimitReader<R> {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use std::io::Cursor;
+    use std::io::{BufReader, Cursor};
 
     #[test]
     fn test_ignition_hash_cli_parse() {
@@ -419,4 +435,30 @@ mod tests {
             "collision with foo at offset 50"
         );
     }
+
+    /// Test that DecompressReader fails if data is appended to the
+    /// compressed stream.
+    #[test]
+    fn test_decompress_reader_trailing_data() {
+        test_decompress_reader_trailing_data_one(&include_bytes!("../fixtures/verify/1M.gz")[..]);
+        test_decompress_reader_trailing_data_one(&include_bytes!("../fixtures/verify/1M.xz")[..]);
+    }
+
+    fn test_decompress_reader_trailing_data_one(input: &[u8]) {
+        let mut input = input.to_vec();
+        let mut output = Vec::new();
+
+        // successful run
+        DecompressReader::new(BufReader::new(&*input))
+            .unwrap()
+            .read_to_end(&mut output)
+            .unwrap();
+
+        // add trailing garbage, make sure we notice
+        input.push(0);
+        DecompressReader::new(BufReader::new(&*input))
+            .unwrap()
+            .read_to_end(&mut output)
+            .unwrap_err();
+    }
 }
